Логические задачи:
1)Дано 100-этажное здание. Если яйцо сбросить с высоты N-го этажа (или с большей высоты), оно разобьется. 
Если его бросить с любого меньшего этажа, оно не разобьется. 
У вас есть два яйца. Найдите N за минимальное количество бросков.


2)Поймал людоед 100 гномов, и сказал, что завтра он всех выстроит в колонну один за другим и оденет всем на головы либо черную, либо белую шапку. 
Гномы будут стоять так, что каждый будет видеть шапки только тех, кто впереди (последний видит всех, кроме себя, а первый – никого). 
Свою собственную шапку гномы не видят. Количество черных и белых шапок произвольное. 
Далее людоед, начиная с последнего, будет каждого спрашивать, какая шапка у него на голове. 
Гном может ответить только одним из двух слов «черная» или «белая». Если ответ неверный, то гном съедается, иначе переходят к следующему.
В процессе поедания все пока еще живые гномы слышат, что происходит сзади, 
то есть хоть они и не видят товарищей сзади, но слышат – когда кого съели, а кого нет, и также их ответы.
В общем, за ночь гномы покумекали, и придумали стратегию, как они все останутся живыми кроме одного. Но и тот один будет иметь шанс выжить.
Вопрос: что за стратегию придумали гномы?


3)Есть 1000 бутылок вина, в одну из которых оказался добавлен сильный яд, и 10 лабораторных мышек. 
Яд убивает мышку за 1 день.
Сегодня вы можете напоить любую мышь из любой бутылки(одна мышь может выпить из нескольких бутылок, несколько мышей могут выпить из одной бутылки).
Завтра какието мыши умрут и вам необходимо определить какая бутылка с ядом. Как это сделать?


*Более простая версия:
4 бутылки и 2 мыши. 


Задачи:
1. Реализовать Stack и Queue с помощью ArrayList. 
Про реализацию очереди и саморасширяющегося массива(ArrayList) можно прочитать тут: 
https://neerc.ifmo.ru/wiki/index.php?title=%D0%9E%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C


https://neerc.ifmo.ru/wiki/index.php?title=%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2
1. Дана матрица a(NxM) и массив запросов q. Запрос это четверка чисел: q  = {x1, y1, x2, y2}  Необходимо для каждого запроса подсчитать сумму элементов в подпрямоугольнике матрицы a с левым верхним углом в точке (x1; y1) и правым нижним углом в точке (x2; y2). 
int[] sum(int[] a, Query[] queries);


1. Дан массив a и целое число k. Необходимо найти максимум для каждых k подряд идущих элементов.
int[] maximums(int[] a, int k);
1. Дано 2 массива. Для каждого элемента второго массива необходимо найти ближайший(модуль разности с которым минимален) элемент из первого массива. 
2. Дан массив из n элементов, Разница между максимальным и минимальным элементом в котором <= k. Необходимо отсортировать его за O(n+k).
3. Дан массив из n элементов, и целое число k. Необходимо найти k-й элемент в отсортированном массиве(то есть k-й по счету элемент) за O(n);
Тут разбор: https://neerc.ifmo.ru/wiki/index.php?title=%D0%9F%D0%BE%D0%B8%D1%81%D0%BA_k-%D0%BE%D0%B9_%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BA%D0%BE%D0%B2%D0%BE%D0%B9_%D1%81%D1%82%D0%B0%D1%82%D
0%B8%D1%81%D1%82%D0%B8%D0%BA%D0%B8
1. В постфиксной записи (или обратной польской записи) операция записывается после двух операндов. Например, сумма двух чисел A и B записывается как A B +. Запись B C + D * обозначает привычное нам (B + C) * D, а запись A B C + D * + означает A + (B + C) * D.
https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%B0%D1%8F_%D0%BF%D0%BE%D0%BB%D1%8C%D1%81%D0%BA%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C


Дана строка с выражением в постфиксной записи. Необходимо посчитать его значение.


Пример:
8 9 + 1 7 - *
Ответ: -102


Строку вводит пользователь. Все числа и знаки отделены пробелом. Детали реализации на твое усмотрение. 








.